#!/usr/bin/env python3
"""Run the Daylily workset monitor or execute targeted monitor actions."""

from __future__ import annotations

import argparse
import logging
import sys
from pathlib import Path
from typing import Optional, Sequence

from daylib.workset_monitor import (
    MonitorConfig,
    MonitorError,
    WorksetMonitor,
    configure_logging,
)

LOGGER = logging.getLogger("daylily.workset_monitor.cli")


def parse_args(argv: Optional[Sequence[str]] = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Monitor S3 workset directories and launch Daylily pipelines",
    )
    parser.add_argument("config", type=Path, help="Path to the YAML configuration file")
    parser.add_argument(
        "--once",
        action="store_true",
        help="Run a single poll iteration and exit (ignored when --action is provided)",
    )
    parser.add_argument("--dry-run", action="store_true", help="Do not mutate S3 or execute commands")
    parser.add_argument(
        "--attempt-restart",
        action="store_true",
        help="Retry failed workset commands once starting from the failed command",
    )
    parser.add_argument("--verbose", action="store_true", help="Enable debug logging")
    parser.add_argument("--debug", action="store_true", help="Print all commands executed (and in dry-run)")
    parser.add_argument(
        "--force-recalculate",
        action="store_true",
        help="Recalculate all remote workset metrics regardless of cache",
    )
    parser.add_argument(
        "--process-directory",
        dest="process_directories",
        metavar="NAME",
        nargs="+",
        help="Only process the specified workset directory names",
    )
    parser.add_argument(
        "--include-archive",
        action="store_true",
        dest="include_archive",
        help="Include archived worksets when executing actions",
    )
    parser.add_argument(
        "--action",
        dest="actions",
        action="append",
        metavar="NAME",
        help="Execute a specific monitor action instead of running the continuous monitor",
    )
    return parser.parse_args(argv)


def main(argv: Optional[Sequence[str]] = None) -> int:
    args = parse_args(argv)
    configure_logging(args.verbose)

    config = MonitorConfig.load(args.config)
    if args.once and not args.actions:
        config.monitor.continuous = False

    monitor = WorksetMonitor(
        config,
        dry_run=args.dry_run,
        debug=args.debug,
        process_directories=args.process_directories,
        attempt_restart=args.attempt_restart,
        force_recalculate_metrics=args.force_recalculate,
    )

    if args.actions:
        try:
            monitor.perform_actions(
                args.actions,
                include_archive=args.include_archive,
            )
        except MonitorError as exc:
            LOGGER.error("Action execution failed: %s", exc)
            return 1
        return 0

    monitor.run()
    return 0


if __name__ == "__main__":
    sys.exit(main())
